# number of bootstrap replications for nonparametric bootstrap
boot_reps = 5000

# for robustness checks: data and code availability included
data_and_code = FALSE

# function to load all required packages and install them if necessary
Install_And_Load <- function(Required_Packages)
{
  Remaining_Packages <-
    Required_Packages[!(Required_Packages %in% installed.packages()[, "Package"])]
  
  
  if (length(Remaining_Packages))
  {
    install.packages(Remaining_Packages)
    
  }
  for (package_name in Required_Packages)
  {
    library(package_name,
            character.only = TRUE,
            quietly = TRUE)
    
  }
}

# Specify the list of required packages to be installed and load
Required_Packages <-
  c("xtable", "boot", "plyr", "dplyr", "data.table")

# Call the Function
Install_And_Load(Required_Packages)

# read in excel files containing the flagged tests as generated by error_detection_algorithm
reg_data <-
  read.csv("data/data_results_cleaned_complete.csv", header = TRUE)
reg_data_strong <-
  read.csv("data/data_results_sign_change_cleaned_complete.csv", header = TRUE)

# change colnames for strong errors
colnames(reg_data_strong)[which(grepl(names(reg_data_strong), pattern =
                                        "prob"))] <-
  c("prob1_strong", "prob2_strong", "prob3_strong")

# append strong errors to dataset with all errors
reg_data <-
  cbind(reg_data, reg_data_strong[, which(grepl(names(reg_data_strong), pattern =
                                                  "prob"))])
rm(reg_data_strong)

# only 7 papers report only negative results, combine category with "nes" (papers reporting negative and positive results)
reg_data$negative_result[reg_data$negative_result == "Nes"] <- "Yes"

### recode table number
# split tables with panel indication such as 1_A
splitlist <-
  strsplit(as.character(reg_data$table_panel), split = "_")

# extract only first entry which is the number of the table or the place in the appendix,
# we want to drop the indicator for the panel
table_num <- numeric(length(reg_data$table_panel))
for (i in 1:length(reg_data$table_panel))
{
  table_num[i] <- splitlist[[i]][1]
}

# get maximum table number (numeric!) for each paper
reg_data$table_num <- as.numeric(table_num)

# maximum table number as new variable
setDT(reg_data)[, max_tab_by_article := max(table_num, na.rm = TRUE), by = paper_id]

## for appendix tables, add tables
reg_data$table_num[table_num == "A"] <-
  reg_data$max_tab_by_article[table_num == "A"] + 1
reg_data$table_num[table_num == "B"] <-
  reg_data$max_tab_by_article[table_num == "B"] + 2
reg_data$table_num[table_num == "C"] <-
  reg_data$max_tab_by_article[table_num == "C"] + 3
reg_data$table_num[table_num == "D"] <-
  reg_data$max_tab_by_article[table_num == "D"] + 4

# count number of tables with tests of interest per paper
setDT(reg_data)[, tab_by_article := length(unique(table_num)), by = paper_id]
reg_data <- as.data.frame(reg_data)

# count number of tests of interest per paper
setDT(reg_data)[, number_of_tests := length(table_num), by = paper_id]

# for paper-based analysis, create variables whether an article contains at least one (strong) error
setDT(reg_data)[, error_yes_no := ((sum(prob1 + prob2)) > 0) * 1, by = paper_id]
setDT(reg_data)[, error_yes_no_strong := ((sum(prob1_strong + prob2_strong)) >
                                            0) * 1, by = paper_id]

# reduce data set to paper level
data_reduced <- distinct(reg_data, paper_id, .keep_all = TRUE)
data_reduced <- arrange(reg_data, first_author)

##### choose initial variables for regressions on paper level: Note that field_2 is not included as it
# contains too many categories with few entries, type not included as it has sometimes more categories per paper

# once inlude data and code availability
if (data_and_code == TRUE)
  vars_paperwise <- c(
    "year",
    "journal_id",
    "field",
    "num_authors",
    "editor_d",
    "tenured_0",
    "phd_age",
    "ras",
    "thanks",
    "negative_result",
    "model",
    "tab_by_article",
    "number_of_tests",
    "data_availability",
    "codes_availability",
    "paper_id"
  ) else
  # do not include data and code availability
  vars_paperwise <-
  c(
    "year",
    "journal_id",
    "field",
    "num_authors",
    "editor_d",
    "tenured_0",
    "phd_age",
    "ras",
    "thanks",
    "negative_result",
    "model",
    "tab_by_article",
    "number_of_tests",
    "paper_id"
  )

# reduced data set (one entry per paper)
reg_data_reduced <- distinct(reg_data, paper_id, .keep_all = TRUE)

######################################################## regressions paperwise
# remove paper id variable
vars_paperwise_noid <-
  vars_paperwise[-which(grepl(vars_paperwise , pattern = "paper_id"))]

# dependent variables of interest
dep_var_pap <- c("error_yes_no", "error_yes_no_strong")

# create factor variables
reg_data_reduced <-
  reg_data_reduced %>% mutate(
    journal_id = factor(journal_id),
    model = factor(model),
    type = factor(type),
    type_emp = factor(type_emp),
    main = factor(main),
    data_availability = factor(data_availability),
    field = factor(field),
    negative_result = factor(negative_result)
  )

# change reference categories: always choose category with most observations except for codes availability because it become confusing otherwise
reg_data_reduced$journal_id <-
  relevel(reg_data_reduced$journal_id, ref = which(table(reg_data_reduced$journal_id) ==
                                                     max(table(
                                                       reg_data_reduced$journal_id
                                                     ))))
reg_data_reduced$model <-
  relevel(reg_data_reduced$model, ref = which(table(reg_data_reduced$model) ==
                                                max(table(
                                                  reg_data_reduced$model
                                                ))))
reg_data_reduced$type <-
  relevel(reg_data_reduced$type, ref = which(table(reg_data_reduced$type) ==
                                               max(table(
                                                 reg_data_reduced$type
                                               ))))
reg_data_reduced$type_emp <-
  relevel(reg_data_reduced$type_emp, ref = which(table(reg_data_reduced$type_emp) ==
                                                   max(table(
                                                     reg_data_reduced$type_emp
                                                   ))))
reg_data_reduced$main  <-
  relevel(reg_data_reduced$main , ref = which(table(reg_data_reduced$main) ==
                                                max(table(
                                                  reg_data_reduced$main
                                                ))))
#reg_data_reduced$codes_availability <- relevel(reg_data_reduced$codes_availability, ref = which(table(reg_data_reduced$codes_availability)==max(table(reg_data_reduced$codes_availability))))
reg_data_reduced$data_availability <-
  relevel(reg_data_reduced$data_availability, ref = which(table(reg_data_reduced$data_availability) ==
                                                            max(
                                                              table(reg_data_reduced$data_availability)
                                                            )))
reg_data_reduced$field <-
  relevel(reg_data_reduced$field, ref = which(table(reg_data_reduced$field) ==
                                                max(table(
                                                  reg_data_reduced$field
                                                ))))
reg_data_reduced$negative_result <-
  relevel(reg_data_reduced$negative_result, ref = which(table(reg_data_reduced$negative_result) ==
                                                          max(
                                                            table(reg_data_reduced$negative_result)
                                                          )))

# keep only important variables
reg_data_reduced <-
  reg_data_reduced %>% select(vars_paperwise, dep_var_pap)

# remove NAs
reg_data_reduced <-
  reg_data_reduced[apply(reg_data_reduced, 1, function (x)
    sum(is.na(x)) < 1),]

# sort data
reg_data_reduced <- arrange(reg_data_reduced, paper_id)

# placeholder for outcome tables
table_list = list()

# placeholder for bootstrap replicates
bootreps_list = list()

# loop over all different dependent variables
for (i in 1:length(dep_var_pap))
{
  # run logistic regression model
  mod_noidw <-
    glm(as.formula(paste(
      dep_var_pap[i],
      paste(vars_paperwise_noid, collapse = " + "),
      sep = " ~ "
    )),
    data = reg_data_reduced, family = "binomial")
  
  # function to initialize bootstrap
  boot.coef <- function(data, indices) {
    data <- data[indices,]
    sig_EG <-
      glm(as.formula(paste(
        dep_var_pap[i],
        paste(vars_paperwise_noid, collapse = " + "),
        sep = " ~ "
      )),
      data = data, family = "binomial")
    coefficients(sig_EG)
  }
  
  # set seed for bootstrap replications
  set.seed(22)
  
  # do the bootstrap
  EG1.boot <- boot(reg_data_reduced, boot.coef, R = boot_reps,
                   ncpus = 1)
  
  # store bootstrap replicates
  bootreps_list[[i]] <- EG1.boot$t
  
  # store bca intervals for all variables
  cis <- as.data.frame(matrix(0, length(EG1.boot$t0), 2))
  for (c in 1:nrow(cis))
  {
    bca_ci <- boot.ci(EG1.boot,
                      index = c,
                      type = "bca",
                      conf = 0.90)
    cis[c,] <- bca_ci$bca[4:5]
  }
  
  # save point estimates and confidence intervals
  results <- cbind(mod_noidw$coefficients, cis)
  
  # set colnames and rownames
  colnames(results)[1] <- "Coefficient"
  if (data_and_code == TRUE)
    rownames(results) <-
    c(
      "Intercept",
      "Year",
      "Journal of Political Economy",
      "Quarterly Journal of Economics",
      "Field: Macroeconomics",
      "Number of authors",
      "Share of editors among authors",
      "Share of tenured authors",
      "Authors' average years since PhD" ,
      "Number of research assistants thanked",
      "Number of individuals thanked",
      "Negative results put forward",
      "With theoretical model",
      "Number of tables",
      "Number of tests",
      "Data available",
      "Code available"
    ) else
    rownames(results) <-
    c(
      "Intercept",
      "Year",
      "Journal of Political Economy",
      "Quarterly Journal of Economics",
      "Field: Macroeconomics",
      "Number of authors",
      "Share of editors among authors",
      "Share of tenured authors",
      "Authors' average years since PhD" ,
      "Number of research assistants thanked",
      "Number of individuals thanked",
      "Negative results put forward",
      "With theoretical model",
      "Number of tables",
      "Number of tests"
    )
  
  # save results and pseudo R squared
  if (dep_var_pap[i] == "error_yes_no") {
    results_any <- round(as.data.frame(results), digits = 4)
    pR2_any = round(1 - mod_noidw$deviance / mod_noidw$null.deviance, digits =
                      4)
  }
  
  if (dep_var_pap[i] == "error_yes_no_strong") {
    results_strong <- round(as.data.frame(results), digits = 4)
    pR2_strong = round(1 - mod_noidw$deviance / mod_noidw$null.deviance, digits =
                         4)
  }
}


# rename rowname
rownames(results)[rownames(results) == "Number of research assistants thanked"] <-
  "Number of res. assistants thanked"


# correlation between journal and data and code availability and the correlation between the latter two
if (data_and_code == TRUE)
{
  # data available, split by journal
  print(
    table(
      reg_data_reduced$journal_id,
      reg_data_reduced$data_availability
    ) /
      apply(
        table(
          reg_data_reduced$journal_id,
          reg_data_reduced$data_availability
        ),
        1,
        sum
      )
  )
  # code available, split by journal
  print(
    table(
      reg_data_reduced$journal_id,
      reg_data_reduced$codes_availability
    ) /
      apply(
        table(
          reg_data_reduced$journal_id,
          reg_data_reduced$codes_availability
        ),
        1,
        sum
      )
  )
  print(
    table(
      reg_data_reduced$data_availability,
      reg_data_reduced$codes_availability
    )
  )
}

# TABLE 7
# first and third column
if (data_and_code == FALSE)
{
  print(results_any)
  print(paste("n:", nrow(reg_data_reduced)))
  print(paste("Pseudo R?:", pR2_any))
  print(results_strong)
  print(paste("n:", nrow(reg_data_reduced)))
  print(paste("Pseudo R?:", pR2_strong))
} else {
  # second and fourth column
  print(results_any)
  print(paste("n:", nrow(reg_data_reduced)))
  print(paste("Pseudo R?:", pR2_any))
  print(results_strong)
  print(paste("n:", nrow(reg_data_reduced)))
  print(paste("Pseudo R?:", pR2_strong))
}
