# number of bootstrap replications for nonparametric bootstrap
boot_reps = 5000

# which regression should be run?
# if model using all variables except for data and code availability, set both of the
# following logical values to FALSE
# Regression using the intercept only:
null_model = FALSE
# Full model using data and code availability
data_and_code = TRUE


# function to load all required packages and install them if necessary
Install_And_Load <- function(Required_Packages)
{
  Remaining_Packages <-
    Required_Packages[!(Required_Packages %in% installed.packages()[, "Package"])]
  
  
  if (length(Remaining_Packages))
  {
    install.packages(Remaining_Packages)
    
  }
  for (package_name in Required_Packages)
  {
    library(package_name,
            character.only = TRUE,
            quietly = TRUE)
    
  }
}

# Specify the list of required packages to be installed and load
Required_Packages <- c("xtable", "boot", "plyr", "dplyr", "data.table")

# Call the Function
Install_And_Load(Required_Packages)

# function to take the last n characters of a string
substrRight <- function(x, n) {
  substr(x, nchar(x) - n + 1, nchar(x))
}

# read in excel files containing the flagged tests as generated by error_detection_algorithm
reg_data <- read.csv("data/data_results_cleaned_complete.csv", header = TRUE)

# only 7 papers report only negative results, combine category with "nes" (papers reporting negative and positive results)
reg_data$negative_result[reg_data$negative_result == "Nes"] <- "Yes"

### recode table number
# split tables with panel indication such as 1_A
splitlist <- strsplit(as.character(reg_data$table_panel), split = "_")

# extract only first entry which is the number of the table or the place in the appendix,
# we want to drop the indicator for the panel
table_num <- numeric(length(reg_data$table_panel))
for (i in 1:length(reg_data$table_panel))
{
  table_num[i] <- splitlist[[i]][1]
}

# append table number (numeric) to data set
reg_data$table_num <- as.numeric(table_num)

# maximum table number as new variable
setDT(reg_data)[, max_tab_by_article := max(table_num, na.rm = TRUE), by = paper_id]

## for appendix tables, add numeric table numbers
reg_data$table_num[table_num == "A"] <-
  reg_data$max_tab_by_article[table_num == "A"] + 1
reg_data$table_num[table_num == "B"] <-
  reg_data$max_tab_by_article[table_num == "B"] + 2
reg_data$table_num[table_num == "C"] <-
  reg_data$max_tab_by_article[table_num == "C"] + 3
reg_data$table_num[table_num == "D"] <-
  reg_data$max_tab_by_article[table_num == "D"] + 4

# count number of tablesper paper
setDT(reg_data)[, tab_by_article := length(unique(table_num)), by = paper_id]
reg_data <- as.data.frame(reg_data)

# count number of tests per paper
setDT(reg_data)[, number_of_tests := length(table_num), by = paper_id]

# anonymize paper id
reg_data$paper_id <-
  paste0(
    nchar(reg_data$first_author),
    sep = "",
    substrRight(reg_data$first_author, 1),
    sep = "",
    reg_data$issue %% 10,
    sep = "",
    reg_data$year %% 5,
    sep = "",
    reg_data$article_page %% 20
  )
length(unique(reg_data$paper_id))

##### choose variables for propensity regression: Note that field_2 is not included as it
# contains too many categories with few entries, type not included as it has sometimes more categories per paper

# once inlude data and code availability
if (data_and_code == TRUE)
  vars_paperwise <- c(
    "year",
    "journal_id",
    "field",
    "num_authors",
    "editor_d",
    "tenured_0",
    "phd_age",
    "ras",
    "thanks",
    "negative_result",
    "model",
    "tab_by_article",
    "number_of_tests",
    "data_availability",
    "codes_availability",
    "paper_id"
  ) else
  # do not include data and code availability
  vars_paperwise <-
  c(
    "year",
    "journal_id",
    "field",
    "num_authors",
    "editor_d",
    "tenured_0",
    "phd_age",
    "ras",
    "thanks",
    "negative_result",
    "model",
    "tab_by_article",
    "number_of_tests",
    "paper_id"
  )

# reduced data set (one entry per paper)
reg_data_reduced <- distinct(reg_data, paper_id, .keep_all = TRUE)

######################################################## regressions paperwise
# remove paper id variable
vars_paperwise_noid <-
  vars_paperwise[-which(grepl(vars_paperwise , pattern = "paper_id"))]

# change reference categories: always choose category with most observations except for codes availability because it become confusing otherwise
reg_data_reduced$journal_id <-
  relevel(as.factor(reg_data_reduced$journal_id), ref = which(table(reg_data_reduced$journal_id) ==
                                                                max(table(
                                                                  reg_data_reduced$journal_id
                                                                ))))
reg_data_reduced$model <-
  relevel(as.factor(reg_data_reduced$model), ref = which(table(reg_data_reduced$model) ==
                                                           max(table(
                                                             reg_data_reduced$model
                                                           ))))
reg_data_reduced$type <-
  relevel(as.factor(reg_data_reduced$type), ref = which(table(reg_data_reduced$type) ==
                                                          max(table(
                                                            reg_data_reduced$type
                                                          ))))
reg_data_reduced$type_emp <-
  relevel(as.factor(reg_data_reduced$type_emp), ref = which(table(reg_data_reduced$type_emp) ==
                                                              max(table(
                                                                reg_data_reduced$type_emp
                                                              ))))
reg_data_reduced$main  <-
  relevel(as.factor(reg_data_reduced$main) , ref = which(table(reg_data_reduced$main) ==
                                                           max(table(
                                                             reg_data_reduced$main
                                                           ))))
reg_data_reduced$data_availability <-
  relevel(as.factor(reg_data_reduced$data_availability),
          ref = which(table(reg_data_reduced$data_availability) == max(
            table(reg_data_reduced$data_availability)
          )))
reg_data_reduced$field <-
  relevel(as.factor(reg_data_reduced$field), ref = which(table(reg_data_reduced$field) ==
                                                           max(table(
                                                             reg_data_reduced$field
                                                           ))))
reg_data_reduced$negative_result <-
  relevel(as.factor(reg_data_reduced$negative_result),
          ref = which(table(reg_data_reduced$negative_result) == max(
            table(reg_data_reduced$negative_result)
          )))

# keep only important variables as defined above
reg_data_reduced <- reg_data_reduced %>% select(c(vars_paperwise))

# remove NAs
reg_data_reduced <-
  reg_data_reduced[apply(reg_data_reduced, 1, function (x)
    sum(is.na(x)) < 1), ]

# load anonymized answers
ans <- read.csv("data/answers_anonymized.csv", header = TRUE)

# reduce to one entry per paper
ans <- distinct(ans, paper_id, .keep_all = TRUE)

# add variable to initial data set indicating whether author responded
reg_data_reduced$resp <- rep(0, nrow(reg_data_reduced))
reg_data_reduced$resp[reg_data_reduced$paper_id %in% as.character(ans$paper_id)] <-
  1

# logistic regression
if (null_model == TRUE)
  mod_noidw <- glm(as.formula(paste("resp", paste(1), sep = " ~ ")),
                   data = reg_data_reduced, family = "binomial") else
  mod_noidw <-
  glm(as.formula(paste(
    "resp", paste(vars_paperwise_noid, collapse = " + "), sep = " ~ "
  )),
  data = reg_data_reduced, family = "binomial")

# function to initialize bootstrap

boot.coef <- function(data, indices) {
  data <- data[indices, ]
  if (null_model == TRUE)
    sig_EG <- glm(as.formula(paste("resp", paste(1), sep = " ~ ")),
                  data = data, family = "binomial") else
    sig_EG <-
      glm(as.formula(paste(
        "resp", paste(vars_paperwise_noid, collapse = " + "), sep = " ~ "
      )),
      data = data, family = "binomial")
  coefficients(sig_EG)
}


# set seed for bootstrap replications
set.seed(22)

# do the bootstrap
EG1.boot <- boot(reg_data_reduced, boot.coef, R = boot_reps)

# store bca intervals for all variables
cis <- as.data.frame(matrix(0, length(EG1.boot$t0), 2))
for (c in 1:nrow(cis))
{
  bca_ci <- boot.ci(EG1.boot,
                    index = c,
                    type = "bca",
                    conf = 0.90)
  cis[c, ] <- bca_ci$bca[4:5]
}

# save point estimates and confidence intervals
results <- cbind(mod_noidw$coefficients, cis)

# set colnames and rownames
colnames(results)[1] <- "Coefficient"
if (null_model == TRUE)
  rownames(results) <- c("Intercept") else
  if (data_and_code == TRUE)
    rownames(results) <-
  c(
    "Intercept",
    "Year",
    "Journal of Political Economy",
    "Quarterly Journal of Economics",
    "Field: Macroeconomics",
    "Number of authors",
    "Share of editors among authors",
    "Share of tenured authors",
    "Authors' average years since PhD" ,
    "Number of research assistants thanked",
    "Number of individuals thanked",
    "Negative results put forward",
    "With theoretical model",
    "Number of tables",
    "Number of tests",
    "Data available",
    "Code available"
  ) else if 
(data_and_code == FALSE & null_model == FALE)
  rownames(results) <-
  c(
    "Intercept",
    "Year",
    "Journal of Political Economy",
    "Quarterly Journal of Economics",
    "Field: Macroeconomics",
    "Number of authors",
    "Share of editors among authors",
    "Share of tenured authors",
    "Authors' average years since PhD" ,
    "Number of research assistants thanked",
    "Number of individuals thanked",
    "Negative results put forward",
    "With theoretical model",
    "Number of tables",
    "Number of tests"
  )

# TABLE A5
# save and print further results
results <- round(as.data.frame(results), digits = 4)
pR2 = round(1 - mod_noidw$deviance / mod_noidw$null.deviance, digits = 4)
aic = round(AIC(mod_noidw), 4)
results
print(c(nrow(reg_data_reduced), pR2, aic))

